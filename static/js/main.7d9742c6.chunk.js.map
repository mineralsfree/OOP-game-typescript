{"version":3,"sources":["model/Units/Unit/unit.ts","model/Constants.js","model/Units/WitchDoctor/Healer.ts","model/Units/Behavior/ActionBehavior.ts","model/Units/Berserk/Berserk.ts","model/Units/Mage/Mage.ts","model/Units/Archer/Archer.ts","model/Field/Constants.js","model/helpers/RandomHelper.js","model/Units/Hexer/Hexer.ts","model/helpers/fillUnitsHelper.js","model/Field/Field.ts","model/Game/sortHelper.js","model/Game/Game.ts","components/Cell/Cell.tsx","components/Field/Field.tsx","components/ActivityStack/ActiveStack.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Unit","maxHP","damage","initiative","type","team","name","attackable","_HP","dead","active","x","y","id","hexed","actionBehavior","attackPossibility","this","getID","value","Math","min","field","arr","forEach","el","i","elem","j","push","target","HP","UnitConstants","witchDoctor","WitchDoctor","RangePossibility","HealBehavior","hexerBehavior","SingleUnitAttackBehavior","enemyField","source","AllUnitsAttackBehavior","AllieField","self","MeleePossibility","aliveLine","length","getAliveLine","fieldSize","berserk","Berserk","mage","archer","FieldSizes","getRandomInt","max","rand","random","floor","hexer","warriors","1","dealMageDamage","2","3","4","5","fill","randomInt","warrior","row1","row2","Field","flatArr","flat","sort","a","b","filter","sortByInitiativity","Game","order","round","activeUnit","fieldA","fieldB","concat","resetValueOfUnit","shift","nextRound","getNextAttackingWarior","teamAlive","targetID","sourceUnit","getFieldToAttack","allieField","getActionTargets","heal","dealDamage","hex","unit","cellCN","cn","Cell","props","className","toLowerCase","join","style","width","Component","fieldCN","FieldComponent","reverse","cells","slice","map","retArr","key","onClick","attack","StackCN","ActiveStack","stack","App","state","game","gameOver","DisplayPossibleUnitsToAttack","update","handleAttackClick","setState","alert","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7d9742c6.chunk.js","sourcesContent":["import {IUnit} from \"./IUnit\";\nimport {Field, ICoordinates} from \"../../Field/Field\";\nimport {IActionBehavior, IActionPossibility} from \"../Behavior/ActionBehavior\";\n\nexport abstract class Unit implements IUnit {\n    set HP(value: number) {\n        if (value < 0) {\n            this.dead = true;\n        }\n        this._HP = Math.min(value, this.maxHP);\n    }\n\n    get HP() {\n        return this._HP;\n    }\n\n    damage: number;\n    maxHP: number;\n    initiative: number;\n    attackable: boolean;\n    _HP: number;\n    team: string;\n    dead: boolean;\n    type: string;\n    active: boolean;\n    x: number;\n    y: number;\n    id: number;\n    hexed: boolean;\n    static i = 0;\n    name: string;\n\n    protected constructor(maxHP: number, damage: number, initiative: number, type: string, team: string, name: string) {\n        this.maxHP = maxHP;\n        this.damage = damage;\n        this.initiative = initiative;\n        this._HP = maxHP;\n        this.team = team;\n        this.type = type;\n        this.id = Unit.getID();\n        this.x = 0;\n        this.y = 0;\n        this.active = false;\n        this.dead = false;\n        this.attackable = false;\n        this.name = name;\n        this.hexed = false;\n    }\n\n    static getID(): number {\n        return Unit.i++;\n    }\n\n    getAttackCoordinates(field: Array<Array<Unit>>): Array<ICoordinates> {\n        let arr: Array<ICoordinates> = [];\n        field.forEach((el, i) => {\n            el.forEach((elem, j) => {\n                if (!elem.dead) {\n                    arr.push({x: elem.x, y: elem.y});\n                }\n            })\n        });\n        return arr;\n    }\n\n    dealDamage(target: Unit, field?: Field) {\n        target.HP -= this.damage;\n    }\n\n   abstract  actionBehavior: IActionBehavior;\n    abstract attackPossibility: IActionPossibility;\n}\n\n","export const UnitConstants = {\n    Berserk: {\n        maxHP: 150,\n        damage: 50,\n        initiative: 9,\n        type:'melee',\n        name: 'Berserk',\n    },\n    Archer: {\n        maxHP: 90,\n        damage: 40,\n        initiative: 12,\n        name: 'Archer',\n        type:'range',\n    },\n    Mage: {\n        maxHP: 50,\n        damage: 20,\n        initiative: 228,\n        name: 'Mage',\n        type: 'Mage',\n    },\n    WitchDoctor: {\n        maxHP: 75,\n        damage: 50,\n        name: 'WitchDoctor',\n        initiative: 1,\n        type: 'healer',\n    },\n    Hexer: {\n        maxHP: 85,\n        damage: 0,\n        name: 'Hexer',\n        initiative: 2211,\n        type: 'hexer',\n    }\n};","import {Unit} from \"../Unit/unit\";\nimport {UnitConstants} from \"../../Constants\";\nimport {Field} from \"../../Field/Field\";\nimport {HealBehavior, IActionBehavior, IActionPossibility, RangePossibility} from \"../Behavior/ActionBehavior\";\nconst  witchDoctor= UnitConstants.WitchDoctor;\nexport class WitchDoctor extends Unit {\n    constructor(team: string){\n        super(witchDoctor.maxHP, witchDoctor.damage, witchDoctor.initiative, witchDoctor.type, team, witchDoctor.name)\n        this.attackPossibility= new RangePossibility();\n        this.actionBehavior =new HealBehavior()\n    }\n    dealDamage(target: Unit, field?: Field) {\n        target.HP+=witchDoctor.damage;\n    }\n    actionBehavior: IActionBehavior;\n    attackPossibility: IActionPossibility;\n}","import {Unit} from \"../Unit/unit\";\nimport {WitchDoctor} from \"../WitchDoctor/Healer\";\n\nexport interface IActionPossibility {\n    getActionTargets(enemyField: Array<Array<Unit>>, AllieField: Array<Array<Unit>>, self: Unit): Array<Unit>\n}\n\nexport interface IActionBehavior {\n    getActionBehaviorType(): string;\n}\n\nexport class hexerBehavior implements IActionBehavior{\n    getActionBehaviorType(): string {\n        return \"Hex\";\n    }\n    hex(target: Unit): void{\n        target.hexed = true;\n    }\n}\n\n\nexport class SingleUnitAttackBehavior implements IActionBehavior {\n    dealDamage(enemyField: Array<Unit>, target: Unit, source: Unit): void {\n        target.HP -= source.damage;\n    }\n\n    getActionBehaviorType(): string {\n        return \"Attack\";\n    }\n}\n\nexport class AllUnitsAttackBehavior implements IActionBehavior {\n    dealDamage(enemyField: Array<Unit>, target: Unit, source: Unit): void {\n        enemyField.forEach((el) => el.HP -= source.damage)\n    }\n    getActionBehaviorType(): string {\n        return \"Attack\";\n    }\n}\n\nexport class HealBehavior implements IActionBehavior {\n    heal(target: Unit, source: Unit): void {\n        target.HP += source.damage;\n    }\n\n    getActionBehaviorType(): string {\n        return \"Heal\";\n    }\n}\n\nexport class RangePossibility implements IActionPossibility {\n    getActionTargets(enemyField: Array<Array<Unit>>, AllieField: Array<Array<Unit>>, self: Unit): Array<Unit> {\n        let field;\n        if (self instanceof WitchDoctor) {\n            field = AllieField;\n        } else {\n            field = enemyField;\n        }\n\n        let arr: Array<Unit> = [];\n        field.forEach((el, i) => {\n            el.forEach((elem, j) => {\n                if (!elem.dead) {\n                    arr.push(elem);\n                }\n            })\n        });\n        return arr;\n    }\n}\n\nexport class MeleePossibility implements IActionPossibility {\n    getActionTargets(enemyField: Array<Array<Unit>>, AllieField: Array<Array<Unit>>, self: Unit): Array<Unit> {\n        const getAliveLine = () => {\n            for (let i = 0; i < enemyField.length; i++) {\n                for (let j = 0; j < enemyField[0].length; j++) {\n                    if (!enemyField[i][j].dead) {\n                        return i;\n                    }\n                }\n            }\n            return 0;\n        }\n        let aliveLine = getAliveLine();\n        const fieldSize = {\n            x: enemyField[0].length,\n            y: enemyField.length\n        }\n        let arr: Array<Unit> = [];\n        if (self.y === 0) {\n            if (self.x === 0 && !enemyField[aliveLine][self.x].dead) {\n                return [enemyField[aliveLine][0], enemyField[aliveLine][1]]\n            } else if (self.x === fieldSize.x - 1 && !enemyField[aliveLine][self.x].dead) {\n                return [enemyField[aliveLine][fieldSize.x - 1], enemyField[aliveLine][fieldSize.x - 2]];\n            } else {\n                // TODO: fix bug\n                for (let i = 0; i < fieldSize.x; i++) {\n                    if (!enemyField[aliveLine][i].dead) {\n\n                        arr.push(enemyField[aliveLine][i])\n                    }\n                }\n            }\n            return arr;\n        }\n        return arr;\n    }\n\n}","import {Unit} from \"../Unit/unit\";\nimport {UnitConstants} from \"../../Constants\";\nimport {ICoordinates} from \"../../Field/Field\";\nimport {\n    IActionBehavior,\n    IActionPossibility,\n    MeleePossibility,\n    SingleUnitAttackBehavior\n} from \"../Behavior/ActionBehavior\";\n\nconst berserk = UnitConstants.Berserk;\nexport class Berserk extends Unit{\n    constructor(team:string ){\n        super(berserk.maxHP, berserk.damage, berserk.initiative, berserk.type, team, berserk.name);\n        this.attackPossibility= new MeleePossibility();\n        this.actionBehavior = new SingleUnitAttackBehavior();\n    }\n    public getAttackCoordinates(field: Array<Array<Unit>>){\n        const getAliveLine = ()=>{\n                for (let i = 0; i < field.length; i++) {\n                    for (let j = 0; j < field[0].length; j++) {\n                        if (!field[i][j].dead){\n                            return i;\n                        }\n                    }\n                }\n            return 0;\n        };\n        let aliveLine = getAliveLine();\n        const fieldSize={\n            x: field[0].length,\n            y: field.length\n        };\n        let arr: Array<ICoordinates> = [];\n        if (this.y === 0) {\n            if (this.x === 0 && !field[aliveLine][this.x].dead) {\n                return [{x: 0, y: aliveLine}, {x: 1, y: aliveLine}]\n            } else if (this.x === fieldSize.x - 1 && !field[aliveLine][this.x].dead) {\n                return [{x: fieldSize.x - 1, y: aliveLine}, {x: fieldSize.x - 2, y: aliveLine}]\n            } else {\n                for (let i = 0; i < fieldSize.x; i++) {\n                    if (!field[aliveLine][i].dead) {\n                        arr.push({x: i, y: aliveLine})\n                    }\n                }\n            }\n            return arr;\n        }\n        return arr;\n    }\n    actionBehavior: IActionBehavior;\n    attackPossibility: IActionPossibility;\n}","import {Unit} from \"../Unit/unit\";\nimport {UnitConstants} from \"../../Constants\";\nimport {Field} from \"../../Field/Field\";\nimport {\n    AllUnitsAttackBehavior, IActionBehavior,\n    IActionPossibility,\n    RangePossibility,\n} from \"../Behavior/ActionBehavior\";\n\nconst mage = UnitConstants.Mage;\n\nexport class Mage extends Unit {\n    constructor(team: string) {\n        super(mage.maxHP, mage.damage, mage.initiative, mage.type, team, mage.name);\n        this.attackPossibility = new RangePossibility();\n        this.actionBehavior = new AllUnitsAttackBehavior();\n\n    }\n\n    dealDamage(target: Unit, field?: Field) {\n        if (field) {\n            field.dealMageDamage(this.damage);\n        }\n    }\n\n    attackPossibility: IActionPossibility;\n    actionBehavior: IActionBehavior;\n}","import {Unit} from \"../Unit/unit\";\nimport {UnitConstants} from '../../Constants'\nimport {\n    IActionBehavior,\n    IActionPossibility,\n    RangePossibility,\n    SingleUnitAttackBehavior\n} from \"../Behavior/ActionBehavior\";\nconst archer = UnitConstants.Archer;\nexport class Archer extends Unit{\n    constructor(team: string) {\n        super(archer.maxHP,archer.damage,archer.initiative,archer.type,team, archer.name);\n        this.attackPossibility = new RangePossibility();\n        this.actionBehavior = new  SingleUnitAttackBehavior();\n    }\n\n    attackPossibility: IActionPossibility;\n    actionBehavior: IActionBehavior;\n\n}","export const FieldSizes ={\n    x: 3,\n    y: 2\n}","\nexport const getRandomInt = (min, max)=> {\n    // случайное число от min до (max+1)\n    let rand = min + Math.random() * (max + 1 - min);\n    return Math.floor(rand);\n}","import {Unit} from \"../Unit/unit\";\nimport {hexerBehavior, IActionBehavior, IActionPossibility, RangePossibility} from \"../Behavior/ActionBehavior\";\nimport {UnitConstants} from \"../../Constants\";\nconst hexer = UnitConstants.Hexer;\nexport class Hexer extends Unit{\n    constructor(team: string) {\n        super(hexer.maxHP, hexer.damage, hexer.initiative, hexer.type, team, hexer.name);\n        this.attackPossibility = new RangePossibility();\n        this.actionBehavior = new hexerBehavior();\n    }\n        actionBehavior: IActionBehavior;\n    attackPossibility: IActionPossibility;\n\n\n}","import {Berserk} from \"../Units/Berserk/Berserk\";\nimport {Mage} from \"../Units/Mage/Mage\";\nimport {Archer} from \"../Units/Archer/Archer\"\nimport {FieldSizes} from \"../Field/Constants\";\nimport {getRandomInt} from './RandomHelper';\nimport {WitchDoctor} from \"../Units/WitchDoctor/Healer\";\nimport {Hexer} from \"../Units/Hexer/Hexer\";\n\nconst warriors = {\n    1: Mage,\n    2: Archer,\n    3: WitchDoctor,\n    4: Hexer,\n    5: Berserk,\n}\nexport const fill = (team) => {\n    let row1 = [];\n    let row2 = [];\n    let randomInt;\n    let warrior;\n    for (let i = 0; i < FieldSizes.x; i++) {\n        randomInt = getRandomInt(1, 4);\n        warrior = new warriors[randomInt](team);\n        row1.push(warrior);\n        warrior.x = i;\n        warrior.y = 0;\n        randomInt = getRandomInt(1, 3);\n        warrior = new warriors[randomInt](team);\n        warrior.x = i;\n        warrior.y = 1   ;\n        row2.push(warrior);\n    }\n    return [row1, row2];\n\n};","import {IField} from \"./IField\";\nimport {Unit} from \"../Units/Unit/unit\";\nimport {fill} from \"../helpers/fillUnitsHelper\";\nexport interface ICoordinates {\n    x: number;\n    y: number;\n}\nexport class Field implements IField{\n    field: Array<Array<Unit>>;\n    team: string;\n    flatArr: Array<Unit>;\n\n    constructor(team: string, field:  Array<Array<Unit>> | null) {\n        this.team = team;\n        this.field = field ? field : fill(team);\n        this.flatArr = this.field.flat();\n    }\n    getUnitsSortedByHealthPoints(): Array<Unit>{\n        return this.flatArr.sort((a,b)=>a.HP > b.HP ? 1: -1);\n    }\n    getUnitByID(id: number): Unit{\n        return this.flatArr.filter((el)=> el.id === id)[0];\n    }\n    dealMageDamage(damage: number): void{\n        this.flatArr.forEach((el)=>{\n            el.HP-=damage;\n        })\n    }\n    teamAlive(): boolean{\n        return this.flatArr.filter((el)=>!el.dead).length>0;\n    }\n    resetValueOfUnit(field: string){\n        this.field.forEach((el, i) => {\n            el.forEach((elem, j) => {\n                    // @ts-ignore\n                    elem[field] = false;\n            })\n        });\n    }\n\n}\n","export const sortByInitiativity = (a,b)=>{\n    if (a.initiative > b.initiative) {\n        return -1;\n    } else if (a.initiative < b.initiative ) {\n        return 1;\n    }\n    return  Math.random() < 0.5 ? 1: -1;\n}","import {IGame} from \"./IGame\";\nimport {Field} from \"../Field/Field\";\nimport {Unit} from \"../Units/Unit/unit\";\nimport {sortByInitiativity} from './sortHelper';\nimport {\n    AllUnitsAttackBehavior,\n    HealBehavior,\n    hexerBehavior,\n    SingleUnitAttackBehavior\n} from \"../Units/Behavior/ActionBehavior\";\n\nexport class Game implements IGame {\n    order: Array<Unit>;\n    round: number;\n    activeUnit: Unit;\n    fieldA: Field;\n    fieldB: Field;\n\n    constructor() {\n        this.fieldA = new Field('A', null);\n        this.fieldB = new Field(\"B\", null);\n        this.order = (this.fieldA.flatArr.concat(this.fieldB.flatArr)).sort(sortByInitiativity);\n        this.activeUnit = this.order[0];\n        this.round = 1;\n    }\n\n    getNextAttackingWarior(): Unit {\n        this.fieldA.resetValueOfUnit('active');\n        this.fieldB.resetValueOfUnit('active');\n        let warrior = this.order.shift();\n        while (warrior && warrior.dead) {\n            warrior = this.order.shift();\n        }\n        if (warrior) {\n            warrior.active = true;\n            this.activeUnit = warrior;\n        } else {\n            this.nextRound();\n            return this.getNextAttackingWarior();\n        }\n        return warrior;\n    };\n\n    private nextRound() {\n        this.order = (this.fieldA.flatArr.concat(this.fieldB.flatArr)).sort(sortByInitiativity).filter((el)=> {\n            return el.hexed ? el.hexed = !el.hexed : true;\n        });\n        this.round++;\n    }\n\n    public gameOver() {\n        return (!(this.fieldB.teamAlive()) || !(this.fieldA.teamAlive()))\n    }\n\n    public dealDamage(targetID: number) {\n        let sourceUnit = this.activeUnit;\n        const [enemyField, allieField  ] = this.getFieldToAttack(sourceUnit);\n        let target = sourceUnit.attackPossibility.getActionTargets(enemyField.field, allieField.field, sourceUnit).filter(el=>el.id === targetID)[0];\n\n        if (!target || target.dead || !target.attackable) {\n            return 0;\n        }\n\n        if (sourceUnit.actionBehavior instanceof HealBehavior) {\n            sourceUnit.actionBehavior.heal(target, sourceUnit);\n        } else if (sourceUnit.actionBehavior instanceof AllUnitsAttackBehavior || sourceUnit.actionBehavior instanceof SingleUnitAttackBehavior) {\n            sourceUnit.actionBehavior.dealDamage(enemyField.flatArr, target, sourceUnit);\n        } else if(sourceUnit.actionBehavior instanceof hexerBehavior ){\n            sourceUnit.actionBehavior.hex(target);\n\n        }\n\n        return 1;\n    }\n    private getFieldToAttack(unit: Unit): Field[] {\n            return unit.team === \"A\" ?  [this.fieldB, this.fieldA] : [this.fieldA, this.fieldB]\n    }\n    public DisplayPossibleUnitsToAttack(unit: Unit): void {\n        this.fieldB.resetValueOfUnit('attackable');\n        this.fieldA.resetValueOfUnit('attackable');\n        let field: Array<Array<Unit>>;\n        let enemyField: Array<Array<Unit>>;\n        if (unit.team === \"A\") {\n            field = this.fieldA.field;\n            enemyField = this.fieldB.field;\n        } else {\n            field = this.fieldB.field;\n            enemyField = this.fieldA.field;\n        }\n        let arr = unit.attackPossibility.getActionTargets(enemyField, field, unit);\n\n        arr.forEach((el) => {\n            if (!el.dead) {\n                el.attackable = true;\n            }\n        });\n    }\n}","import React, {Component} from 'react';\nimport {cn} from \"@bem-react/classname\";\nimport './Cell.sass'\nimport {Unit} from \"../../model/Units/Unit/unit\";\n\nexport interface ICellComponentProps {\n    warrior:  Unit,\n}\n\nconst cellCN = cn('cell');\n\nexport class Cell extends Component<ICellComponentProps, any> {\n\n\n    render(): React.ReactElement<any, string | React.JSXElementConstructor<any>> | string | number | {} | React.ReactNodeArray | React.ReactPortal | boolean | null | undefined {\n        const warrior = this.props.warrior;\n        const className = [\n            cellCN(warrior.name.toLowerCase()),\n            cellCN('container'),\n            warrior.active? cellCN( 'active'): '',\n            warrior.attackable? cellCN('attackable'): '',\n            warrior.dead? cellCN('dead'): '',\n            warrior.hexed? cellCN('hexed'): ''\n\n        ]\n        return (\n            <div className={className.join(' ')}>\n                {warrior.id}\n                {!warrior.dead ?                 <span  className={cellCN('health')} style={{width: `${warrior.HP/warrior.maxHP*100}%`}}/> : ''}\n            </div>)\n    }\n}","import React, {Component} from 'react';\nimport {cn} from '@bem-react/classname'\nimport './Field.sass'\nimport {Field} from \"../../model/Field/Field\";\nimport {Cell} from \"../Cell/Cell\";\nimport {Unit} from \"../../model/Units/Unit/unit\";\nconst fieldCN = cn('field');\nexport interface IFieldComponentProps{\n    field: Field\n    reverse?: boolean;\n    attack(e: any): void;\n}\nexport class FieldComponent extends Component<IFieldComponentProps, any>{\n    render(): React.ReactElement<any, string | React.JSXElementConstructor<any>> | string | number | {} | React.ReactNodeArray | React.ReactPortal | boolean | null | undefined {\n        let field = this.props.field.field;\n        const { reverse } = this.props;\n        let lField;\n        if (this.props.reverse){\n            lField =  field.slice().reverse();\n\n        } else {\n            lField = field;\n        }\n        const cells=lField.map((el, i)=>{\n            let retArr:  JSX.Element[] = [];\n            el.forEach((elem: Unit, j)=>{\n                retArr.push(<div key={j} className={fieldCN('cell')} id={''+elem.id} onClick={()=>this.props.attack(elem.id)}>\n                    <Cell  key={j}  warrior={elem}/>\n                </div>)\n            });\n            return (<><div key={i}>{retArr}</div></>)\n        });\n        return (< div className={fieldCN('container')}>\n            {!reverse ? <hr/> : ''}\n            {cells}\n        </div>);\n    }\n}","import React, {Component} from 'react';\nimport './ActiveStack.sass';\nimport {Unit} from \"../../model/Units/Unit/unit\";\nimport {Cell} from \"../Cell/Cell\";\nimport {cn} from \"@bem-react/classname\";\n\nconst StackCN = cn('stack');\n\nexport interface IActiveStack {\n    stack: Array<Unit>\n}\n\nexport class ActiveStack extends Component<IActiveStack, any> {\n    render(): React.ReactElement<any, string | React.JSXElementConstructor<any>> | string | number | {} | React.ReactNodeArray | React.ReactPortal | boolean | null | undefined {\n        const arr = this.props.stack.map((el, i) => {\n            return (<>{!el.dead ?\n                <div > {el.team} <Cell warrior={el}/>\n                </div>\n                : <></>}</>)\n        })\n        return (<div className={StackCN('container')}>\n            {arr}\n        </div>)\n    }\n}","import React, {Component} from 'react';\nimport './App.css';\nimport {Game} from \"./model/Game/Game\";\nimport {FieldComponent} from \"./components/Field/Field\";\nimport {ActiveStack} from \"./components/ActivityStack/ActiveStack\";\n\nexport class App extends Component {\n    state = {\n        game: new Game(),\n        gameOver: false,\n    };\n    DisplayPossibleUnitsToAttack = () => {\n        this.state.game.DisplayPossibleUnitsToAttack(this.state.game.getNextAttackingWarior());\n        this.update();\n    };\n    handleAttackClick = (id: number) => {\n        const game = this.state.game;\n        if (game.dealDamage(id)) {\n            if (game.gameOver()) {\n                this.setState({\n                        ...this.state,\n                        gameOver: !this.state.gameOver\n                    }\n                );\n            }\n            this.DisplayPossibleUnitsToAttack();\n        } else {\n            alert('чел ты...')\n        }\n    };\n    update = () => {\n        this.setState({\n                ...this.state,\n                game: this.state.game\n            }\n        )\n    }\n\n    componentDidMount(): void {\n        this.DisplayPossibleUnitsToAttack();\n\n    }\n\n    render() {\n        return (\n            <div className=\"App\">\n                <header className=\"App-header\">\n                    {this.state.gameOver ? \"GAME OVER, PRESS F5 To PLAY AGAIN\" : `Round : ${this.state.game.round}`}\n                    <ActiveStack stack={this.state.game.order}/>\n                    <div>\n                        TEAM A\n                        <FieldComponent attack={this.handleAttackClick} field={this.state.game.fieldA} reverse={true}/>\n                        <FieldComponent attack={this.handleAttackClick} field={this.state.game.fieldB}/>\n                        TEAM B\n                    </div>\n                </header>\n            </div>\n        );\n    }\n\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}